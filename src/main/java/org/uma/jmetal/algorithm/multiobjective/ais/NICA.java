package org.uma.jmetal.algorithm.multiobjective.ais;

import org.apache.commons.lang3.tuple.Pair;
import org.uma.jmetal.algorithm.Algorithm;
import org.uma.jmetal.operator.MutationOperator;
import org.uma.jmetal.problem.Problem;
import org.uma.jmetal.solution.DoubleSolution;
import org.uma.jmetal.util.comparator.CrowdingDistanceComparator;
import org.uma.jmetal.util.evaluator.SolutionListEvaluator;
import org.uma.jmetal.util.evaluator.impl.SequentialSolutionListEvaluator;
import org.uma.jmetal.util.solutionattribute.Ranking;
import org.uma.jmetal.util.solutionattribute.impl.CrowdingDistance;
import org.uma.jmetal.util.solutionattribute.impl.DominanceRanking;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;


/**
 *  The Novel Inmmune Clonal Algorithm (NICA) for MO Problems
 *
 *  The NICA algorithm is based on the description provided in the following paper:
 *  "Ronghua Shang, Licheng Jiao, Fang Liu, and Wenping Ma. A Novel Immune Clonal Algorithm for MO Problems."
 *
 */

public class NICA implements Algorithm<List<DoubleSolution>> {

    private int                                     populationSize;
    private int                                     cloneScale; // in the paper is referred to as m_c
    private int                                     maxGenerations;
    private List<DoubleSolution>                    antibodyPopulation;
    private Problem<DoubleSolution> problem;
    private MutationOperator<DoubleSolution> mutationOperator;
    private SolutionListEvaluator<DoubleSolution> evaluator;


    /**
     * NICA for solving a problem given a population size equal to populationSize and in maximum maxGenerations.
     *
     * The antibodies operated by NICA will be generated by means of applying mutation operator.
     *
     * @param populationSize
     * @param maxGenerations
     * @param problem
     * @param mutationOperator

     */
    public NICA(int populationSize, int maxGenerations, int cloneScale
            , Problem<DoubleSolution> problem
            , MutationOperator<DoubleSolution> mutationOperator) {
        this.populationSize     = populationSize;
        this.maxGenerations     = maxGenerations;
        this.cloneScale         = cloneScale;
        this.problem            = problem;
        this.mutationOperator   = mutationOperator;
        this.evaluator          = new SequentialSolutionListEvaluator<>();
    }

    @Override
    public void run() {
        List<DoubleSolution> unEvaluatedPopulation  = Utils.createInitialPopulation(getProblem(),getPopulationSize());
        this.antibodyPopulation                     = this.evaluator.evaluate(unEvaluatedPopulation,getProblem());

        int numberOfGenerations = 0;
        while (numberOfGenerations < getMaxGenerations()) {
            List<DoubleSolution> clonedPopulation           = this.generateClones(this.antibodyPopulation);

            List<DoubleSolution> mutatedAntiBodies          = this.performGeneOperation(clonedPopulation);

            List<DoubleSolution> evaluatedMutatedAntiBodies = this.evaluator.evaluate(mutatedAntiBodies,getProblem());

            List<DoubleSolution> dominatingAntibodies       = this.performClonalSelection(evaluatedMutatedAntiBodies);

            List<DoubleSolution> selectedAntiBodies         = this.performAPUSelection(dominatingAntibodies);

            this.antibodyPopulation = selectedAntiBodies;
            numberOfGenerations++;
        }
    }

    @Override
    public List<DoubleSolution> getResult() {
        return this.antibodyPopulation;
    }

    @Override
    public String getName() {
        return "NICA";
    }

    @Override
    public String getDescription() {
        return "A Novel Immune Clonal Algorithm for MO Problems";
    }

    /**
     * Returns a function in charge of providing the result of cloning a single antibody
     * @param copies
     * @return Return a function that takes as parameter a solution and replicates it a number of <code>copies</code>
     * times
     *
     * Example:
     *
     * Given a <code>DoubleSolution</code> whose variables can be represented as <0.2, 0.3, 0.4, 0.2> and given a value
     * of <code>copies</code> equal to 4, the returned function will create the following result for that input:
     *
     * {<0.2, 0.3, 0.4, 0.2>,
     * <0.2, 0.3, 0.4, 0.2>,
     * <0.2, 0.3, 0.4, 0.2>,
     * <0.2, 0.3, 0.4, 0.2>}
     *
     * i.e., a List containing <code>copies</code> times that individual
     */
    private Function<DoubleSolution, List<DoubleSolution>> getCloneIndividualOperation(int copies) {
        return s -> {
          List<DoubleSolution> listOfCopies = new ArrayList<>(copies);
          for (int i = 0; i < copies; i++){
              listOfCopies.add((DoubleSolution) s.copy());
          }
          return listOfCopies;
        };
    }

    /**
     * Clones a whole population using the factor defined by <@link>getCloneScale()</@link>
     * @param populationToClone
     * @return A list containing all the clones for all the elements
     */
    private List<DoubleSolution> generateClones(List<DoubleSolution> populationToClone) {
        return populationToClone.stream()
                                .map(getCloneIndividualOperation(this.getCloneScale()))
                                .collect(ArrayList::new, ArrayList::addAll, ArrayList::addAll);
    }

    /**
     * Returns the number of clones that should be generated for each anti-body
     *
     * In the original paper this function return the value indicated by m_c
     * @return
     */
    private int getCloneScale() {
        return this.cloneScale;
    }

    /**
     * Modifies the content of a whole population by means of a mutation operator
     * @param populationToOperate is a mutable list whose content is to be modified
     * @return The list with modified content
     */
    private List<DoubleSolution> performGeneOperation(List<DoubleSolution> populationToOperate) {
        return populationToOperate.stream()
                                  .map(s->mutationOperator.execute(s))
                                  .collect(Collectors.toList());
    }

    /**
     * Selects the non-dominated solutions out of a given population
     *
     * It has the same effect than the following piece of code:
     * Ranking<DoubleSolution> ranking;
     * ranking.computeRanking(populatonToSelectFrom);
     * return ranking.getFront(0)
     *
     *
     * @param populationToSelectFrom
     * @return
     */
    private List<DoubleSolution> performClonalSelection(List<DoubleSolution> populationToSelectFrom) {
           return  divideAntibodies(populationToSelectFrom).getLeft();
    }

    /**
     * Divides a population into non-dominated and dominated solutions. The first group is returned as the left element
     * of a <code>Pair</code> and the second group is returned as the <code>right</code> element of the same
     * <code>Pair</code>
     *
     * @param populationToDivide Is the population whose non-dominated and dominated solutions we want separate
     * @return A <code>Pair</code> with the result of the division. Non-dominated solutions are returned in a list that
     * can be accessed through the left element of the Pair. A list of non-dominated solutions can be accessed as the
     * right element of the pair.
     */
    private Pair<List<DoubleSolution>,List<DoubleSolution>> divideAntibodies(List<DoubleSolution> populationToDivide) {
        Ranking<DoubleSolution> rankingOperator = new DominanceRanking<>();
        rankingOperator.computeRanking(populationToDivide);

        List<DoubleSolution> dominatedSolutions = new ArrayList<>(populationToDivide.size());
        for (int front = 1;front < rankingOperator.getNumberOfSubfronts(); front++) {
            //front 0 contains non-dominated solutions and we are interested in dominated
            dominatedSolutions.addAll(rankingOperator.getSubfront(front));
        }

        return Pair.of(rankingOperator.getSubfront(0),dominatedSolutions);
    }

    /**
     * Selects the elements in the less crowded area of a population
     * @param populationToSelectFrom Mutable list containing the list of elements from where the selection will take
     *                               place
     * @return
     */
    private List<DoubleSolution> performAPUSelection(List<DoubleSolution> populationToSelectFrom) {
        CrowdingDistance<DoubleSolution> crowdingDistance = new CrowdingDistance<>();

        while (populationToSelectFrom.size() > this.getPopulationSize()) {
            crowdingDistance.computeDensityEstimator(populationToSelectFrom);

            DoubleSolution mostCrowded = populationToSelectFrom.stream().max(new CrowdingDistanceComparator<>()).get();

            populationToSelectFrom.remove(mostCrowded);
        }

        return populationToSelectFrom;
    }

    private Problem<DoubleSolution> getProblem() {
        return this.problem;
    }

    private int getPopulationSize() {
        return this.populationSize;
    }

    private MutationOperator<DoubleSolution> getMutationOperator() {
        return this.mutationOperator;
    }

    private int getMaxGenerations() {
        return this.maxGenerations;
    }
}
